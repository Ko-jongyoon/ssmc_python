# 클래스(class), 객체(object)
# 객체지향프로그램 ( Objected Oriented Programing :OOP )
# 객체:이세상에 존재하는 모든 사물(유형), 사상(무형)을 통칭
# 이런 객체를 프로그램에 구현을 한다고 한다면, 뭔가 기술하는
# 기준, 특, 문법들은 형식필요하다 ->Class
# Class는 object의 청사진이다
##############################################################
# 클래스는 배우는 목적은 객체를 기술하기 위함
# 클래스를 생성하면 -> 객체가 생성된다(메모리상)
# 9번 표현의 요약은 class의 인스턴스는 object다
##############################################################
# 객체는 공통된 2가지 특징을 가진다
# 속성(특성) => 사람이라는 객체를 기준 ==> 눈, 코, 입...
# 행동(액션) => 사람이라는 객체를 기준 ==> 먹는다, 잔다, 걷는다
##############################################################
# class 문법 => OOP 프로그램을 작성하기 위함
# => 재상용성이 높아지고, OOP의 특징중에 상속을 활요하면 
# 버전업이나, 기타 높은 확장성을 구사할수있다
##############################################################
'''
class 클래스명(첫글자 대문자로 사용하는 것이 암묵적 룰) :
    # 멤버 변수: 속성(특성)
    # 멤버 함수: 행동(액션)
    # 생성자:constructor-> 함수
'''
# person class 구성
class Person: 
    # 멤버 변수:속성(특성)
    name = None
    age = 0
    # 멤버 함수: 행동(액션)
    # 멤버 함수의 1번인자는 무조건 self이다
    # self : 자기자신 객체를 가르킴 =>타언어 (this)
    def eat( self ):
        print( 'eat() call')
# 3. 생성자(생성함수)
# 객체를 생성하는 역학을 담당
# 메모리에 공간을 할당, 이주소를 반환, 참조카운트 증가(차후
    def __init__( self, name ):
        print('생성자 Call')
        # 멤버 변수 사용시
        # self.변수명
        self.name = name
        # 멤버 함수를 class 내부에서 호출한다면
        self.eat()
        print('-'*10)

#객체 생성
#클레스명 (인자는 생성자의 인자 형식에 맞추면 된다)
obj = Person('multi')
print( obj.name )
obj.eat()